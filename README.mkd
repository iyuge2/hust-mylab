#<center>os-lab-notes  
###进程的创建与进程之间通信  
    本次实验中,涉及了Linux环境下子进程的创建(fork),父子进程之间信号的传(signal)以及兄弟进程之间数据的传递(管道)  
####*1.[进程的创建](#readme)* 
    使用fork()函数可以直接创建一个当前进程的副本,该函数无参,但是,有两个返回值. 返回值中等于0的为子进程,大于0的为父进程.  
    所以,可以采用如下方式对两个进程进行操作.  
    int p1;  
    p1 = fork();  
    if(p1 == 0){  
        ;//执行子进程操作  
    }  
    else{//实际上是else if(p1 > 0)  
        ;//执行父进程操作  
    }  
注意:首先,要明白进程与上次线程之间的区别,线程之间是共用地址空间的,需要特别理解其中副本的概念,就是父子进程虽然有不同的地址空间,  
但是两者会执行完全相同的两份代码,因此,若要再用父进程创建一个子进程,应该在只有父进程可以进入的语句块中去再次fork(),创建子进程2,  
否则,若在语句p1=fork();后面加上p2=fork();那么,后面那条fork语句将会被执行两次,分别是父进程和子进程1创建的.显然这不是我们所需  
要的.而采用前面的方式,当父进程需要创建多个子进程时,if-else的深度将是不可想象的.为了避免这个,可以使用exec函数族,使得父子进程相  
互独立.因此,linux中去创建一个真正独立的子进程往往需要两步--fork()&&exec(这是一个函数族).  
引申:  
    exec函数族的作用是根据指定的文件名找到可执行文件,并用它来取代调用进程的内容.即在调用进程内部执行一个可执行文件.这个可执行  
文件可以是二进制文件,也可以是任何Linux下可执行的脚本文件.  
    exec函数族中包括六个函数:(path-->文件路径)  
        int execl(const char*path,const char*arg,...);  
        int execlp(const char* file,const char*arg,...);  
        int execle(const char*path,const char*arg,...,char*const envp[]);  
        int execv(const char*path,char*const argv[]);  
        int execvp(const char*file,char* const argv[]);  
        int execve(const char*path,char*const argv[],char*const envp[]);  
    exec用被执行的程序替换调用它的程序,与fork的区别是:fork创建一个新的进程,产生一个新的PID;exec启动一个新程序,替换原有的进  
程,因此进程的PID不会改变.两者经常搭配使用. 如一个进程希望执行另一个程序时,就可以先利用fork函数创建出一个新进程,然后调用任何一  
个exec函数执行希望执行的那个程序.
    
    
